import VerbwireApiDocumentation from "./autogeneratedSDK/src/index.js";
import json from "./config/api-docs.json" assert { type: "json" };

export default function (apiKey) {
  var defaultClient = VerbwireApiDocumentation.ApiClient.instance;

  // Configure API key authorization: APIKey
  var APIKey = defaultClient.authentications["APIKey"];
  APIKey.apiKey = apiKey;
  var module = {};

  // update  generated modules and functions start
  module.data = {};
  module.data.owned = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/owned`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/owned`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/owned`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataOwnedGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataOwnedGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.created = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/created`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/created`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/created`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataCreatedGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataCreatedGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.transactions = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/transactions`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transactions`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transactions`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataTransactionsGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataTransactionsGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.transactionsByContract = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/transactionsByContract`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transactionsByContract`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transactionsByContract`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataTransactionsByContractGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataTransactionsByContractGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.nftDetails = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/nftDetails`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/nftDetails`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/nftDetails`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataNftDetailsGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataNftDetailsGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.lastFloorPriceForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/lastFloorPriceForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/lastFloorPriceForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/lastFloorPriceForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataLastFloorPriceForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataLastFloorPriceForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.lastFloorPriceForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/lastFloorPriceForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/lastFloorPriceForContractAddress`].get
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/lastFloorPriceForContractAddress`].get
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataLastFloorPriceForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataLastFloorPriceForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.floorPricesForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/floorPricesForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/floorPricesForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/floorPricesForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataFloorPricesForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataFloorPricesForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.floorPricesForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/floorPricesForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/floorPricesForContractAddress`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/floorPricesForContractAddress`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataFloorPricesForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataFloorPricesForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.historicalStatsForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/historicalStatsForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/historicalStatsForSlug`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/historicalStatsForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataHistoricalStatsForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataHistoricalStatsForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.historicalStatsForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/historicalStatsForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/historicalStatsForContractAddress`].get
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/historicalStatsForContractAddress`].get
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataHistoricalStatsForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataHistoricalStatsForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.salesEventsForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/salesEventsForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/salesEventsForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/salesEventsForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataSalesEventsForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataSalesEventsForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.salesEventsForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/salesEventsForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/salesEventsForContractAddress`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/salesEventsForContractAddress`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataSalesEventsForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataSalesEventsForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.transferEventsForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/transferEventsForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transferEventsForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transferEventsForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataTransferEventsForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataTransferEventsForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.transferEventsForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/transferEventsForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transferEventsForContractAddress`].get
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/transferEventsForContractAddress`].get
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataTransferEventsForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataTransferEventsForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.ownershipForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/ownershipForSlug`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/ownershipForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/ownershipForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataOwnershipForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataOwnershipForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.ownershipForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/ownershipForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/ownershipForContractAddress`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/ownershipForContractAddress`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataOwnershipForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataOwnershipForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.collectionsall = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(json.paths[`/nft/data/collections/all`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/collections`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/collections`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataCollectionsAllGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataCollectionsAllGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.collectionssearch = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/collections/search`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/collections`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/collections`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataCollectionsSearchGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataCollectionsSearchGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.attributesForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/attributesForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesForSlug`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataAttributesForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataAttributesForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.attributesForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/attributesForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesForContractAddress`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesForContractAddress`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataAttributesForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataAttributesForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.attributesWithTokensForSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/attributesWithTokensForSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesWithTokensForSlug`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesWithTokensForSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataAttributesWithTokensForSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataAttributesWithTokensForSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.attributesWithTokensForContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/attributesWithTokensForContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesWithTokensForContractAddress`].get
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/attributesWithTokensForContractAddress`].get
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataAttributesWithTokensForContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataAttributesWithTokensForContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.searchAttributesInSlug = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/searchAttributesInSlug`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/searchAttributesInSlug`].get.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/searchAttributesInSlug`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataSearchAttributesInSlugGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataSearchAttributesInSlugGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.data.searchAttributesInContractAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DataApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/data/searchAttributesInContractAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/searchAttributesInContractAddress`].get
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/data/searchAttributesInContractAddress`].get
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDataSearchAttributesInContractAddressGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDataSearchAttributesInContractAddressGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.deploy = {};
  module.deploy.deployCollectionContract = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DeployApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/deploy/deployCollectionContract`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/deployCollectionContract`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/deployCollectionContract`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDeployDeployCollectionContractPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDeployDeployCollectionContractPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.deploy.deployCustomContract = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DeployApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/deploy/deployCustomContract`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/deployCustomContract`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/deployCustomContract`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDeployDeployCustomContractPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDeployDeployCustomContractPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.deploy.burn = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DeployApi();
      let methodType = JSON.stringify(json.paths[`/nft/deploy/burn`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/burn`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/burn`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDeployBurnPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDeployBurnPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.deploy.updateContract = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DeployApi();
      let methodType = JSON.stringify(json.paths[`/nft/deploy/updateContract`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/updateContract`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/updateContract`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDeployUpdateContractPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDeployUpdateContractPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.deploy.updatewithdrawFunds = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.DeployApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/deploy/update/withdrawFunds`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/update`].post.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/deploy/update`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftDeployUpdateWithdrawFundsPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftDeployUpdateWithdrawFundsPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.update = {};
  module.update.initCollectionContract = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UpdateApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/update/initCollectionContract`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/initCollectionContract`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/initCollectionContract`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUpdateInitCollectionContractPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUpdateInitCollectionContractPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.update.transferOperator = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UpdateApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/update/transferOperator`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/transferOperator`].post.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/transferOperator`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUpdateTransferOperatorPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUpdateTransferOperatorPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.update.addToAllowList = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UpdateApi();
      let methodType = JSON.stringify(json.paths[`/nft/update/addToAllowList`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/addToAllowList`].post.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/update/addToAllowList`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUpdateAddToAllowListPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUpdateAddToAllowListPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.mint = {};
  module.mint.quickMintFromFile = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.MintApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/mint/quickMintFromFile`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/quickMintFromFile`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/quickMintFromFile`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftMintQuickMintFromFilePost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftMintQuickMintFromFilePost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.mint.quickMintFromMetadataUrl = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.MintApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/mint/quickMintFromMetadataUrl`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/quickMintFromMetadataUrl`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/quickMintFromMetadataUrl`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftMintQuickMintFromMetadataUrlPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftMintQuickMintFromMetadataUrlPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.mint.collectionReserveMint = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.MintApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/mint/collectionReserveMint`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/collectionReserveMint`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/collectionReserveMint`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftMintCollectionReserveMintPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftMintCollectionReserveMintPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.mint.customContractMintFromMetadataUrl = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.MintApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/mint/customContractMintFromMetadataUrl`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/customContractMintFromMetadataUrl`].post
            .requestBody.content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/customContractMintFromMetadataUrl`].post
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftMintCustomContractMintFromMetadataUrlPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftMintCustomContractMintFromMetadataUrlPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.mint.customContractMintFromFile = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.MintApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/mint/customContractMintFromFile`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/customContractMintFromFile`].post.requestBody
            .content["multipart/form-data"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/mint/customContractMintFromFile`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftMintCustomContractMintFromFilePost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftMintCustomContractMintFromFilePost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.store = {};
  module.store.file = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.StoreApi();
      let methodType = JSON.stringify(json.paths[`/nft/store/file`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/file`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/file`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftStoreFilePost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftStoreFilePost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.store.fileFromUrl = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.StoreApi();
      let methodType = JSON.stringify(json.paths[`/nft/store/fileFromUrl`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/fileFromUrl`].post.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/fileFromUrl`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftStoreFileFromUrlPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftStoreFileFromUrlPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.store.metadataFromImageUrl = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.StoreApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/store/metadataFromImageUrl`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/metadataFromImageUrl`].post.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/metadataFromImageUrl`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftStoreMetadataFromImageUrlPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftStoreMetadataFromImageUrlPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.store.metadataFromImage = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.StoreApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/store/metadataFromImage`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/metadataFromImage`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/metadataFromImage`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftStoreMetadataFromImagePost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftStoreMetadataFromImagePost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.store.uploadDirectory = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.StoreApi();
      let methodType = JSON.stringify(json.paths[`/nft/store/uploadDirectory`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/uploadDirectory`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/store/uploadDirectory`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftStoreUploadDirectoryPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftStoreUploadDirectoryPost(
          reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.send = {};
  module.send.quickSend = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.SendApi();
      let methodType = JSON.stringify(json.paths[`/nft/send/quickSend`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/quickSend`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/quickSend`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftSendQuickSendPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftSendQuickSendPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.send.enableCrossChainSend = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.SendApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/send/enableCrossChainSend`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/enableCrossChainSend`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/enableCrossChainSend`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftSendEnableCrossChainSendPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftSendEnableCrossChainSendPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.send.crossChainSend = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.SendApi();
      let methodType = JSON.stringify(json.paths[`/nft/send/crossChainSend`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/crossChainSend`].post.requestBody.content[
            "multipart/form-data"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/send/crossChainSend`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftSendCrossChainSendPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftSendCrossChainSendPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user = {};
  module.user.deployedContracts = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/userOps/deployedContracts`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/deployedContracts`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/deployedContracts`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsDeployedContractsGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsDeployedContractsGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.nftsMinted = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(json.paths[`/nft/userOps/nftsMinted`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/nftsMinted`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/nftsMinted`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsNftsMintedGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsNftsMintedGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.ipfsUploads = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(json.paths[`/nft/userOps/ipfsUploads`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/ipfsUploads`].get.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/ipfsUploads`].get.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsIpfsUploadsGet(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsIpfsUploadsGet(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.transactionDetails = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/userOps/transactionDetails`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/transactionDetails`].post.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/transactionDetails`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsTransactionDetailsPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsTransactionDetailsPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.userCollectionContractDetails = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/userOps/userCollectionContractDetails`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/userCollectionContractDetails`].post
            .requestBody.content["application/x-www-form-urlencoded"].schema
            .properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/userCollectionContractDetails`].post
            .parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsUserCollectionContractDetailsPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsUserCollectionContractDetailsPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.payeeAtIndex = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(json.paths[`/nft/userOps/payeeAtIndex`]);
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/payeeAtIndex`].post.requestBody.content[
            "application/x-www-form-urlencoded"
          ].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/payeeAtIndex`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsPayeeAtIndexPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsPayeeAtIndexPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.allowListSharesForAddress = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/userOps/allowListSharesForAddress`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/allowListSharesForAddress`].post.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/allowListSharesForAddress`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsAllowListSharesForAddressPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsAllowListSharesForAddressPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };
  module.user.contractPaymentDetails = function (req) {
    return new Promise((resolve) => {
      let apiInstance = new VerbwireApiDocumentation.UserApi();
      let methodType = JSON.stringify(
        json.paths[`/nft/userOps/contractPaymentDetails`]
      );
      const methodTypeparse = JSON.parse(methodType);
      var methodTypeGetOrPost = Object.keys(methodTypeparse);
      let reqDataValues = [];
      let optsData = null;
      if (methodTypeGetOrPost[0] === "post") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/contractPaymentDetails`].post.requestBody
            .content["application/x-www-form-urlencoded"].schema.properties
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        for (const x in myObj) {
          reqData += req[x] + ",";
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
      } else if (methodTypeGetOrPost[0] === "get") {
        let reqBody = JSON.stringify(
          json.paths[`/nft/userOps/contractPaymentDetails`].post.parameters
        );
        const myObj = JSON.parse(reqBody);
        let reqData = "";
        let opts = [];
        for (let k = 0; k < myObj.length; k++) {
          if (myObj[k]["required"] === true) {
            reqData += req[myObj[k]["name"]] + ",";
          } else {
            opts[myObj[k]["name"]] = req[myObj[k]["name"]];
          }
        }
        reqDataValues = reqData.split(",");
        reqDataValues.pop();
        optsData = opts;
      }
      if (optsData !== null) {
        apiInstance.nftUserOpsContractPaymentDetailsPost(
          ...reqDataValues,
          optsData,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      } else {
        apiInstance.nftUserOpsContractPaymentDetailsPost(
          ...reqDataValues,
          (error, data, response) => {
            resolve(response.body);
          }
        );
      }
    });
  };

  // update  generated modules and functions end

  return module;
}
